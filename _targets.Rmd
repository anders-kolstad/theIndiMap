---
title: "IndiMap plots and analyses"
output: html_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

This report will

- compile indicator profiles `"/data/indicatorProfiles/"` and publication profiles `"/data/pulicationProfiles/"` into long format
- Perform resampling to craete dummy data
- Create plots and summary statistics


<!-- Target Markdown is a powerful R Markdown interface for reproducible analysis pipelines, and the chapter at https://books.ropensci.org/targets/markdown.html walks through it in detail. This R Markdown report the example from the chapter. Try it out in both interactive and non-interactive modes, either by running the code chunks in different ways or setting the `tar_interactive` chunk option. -->

# Set-up
<details><summary>Click to expand</summary>

Here are the required packages

```{r, eval = FALSE}
install.packages(c("tidyverse", "reactable"))
```


```{r, echo=T, warning=F, message=F}
library(targets)
library(tidyverse)
#library(DT)
library(reactable)
```


```{targets setup-targets, tar_globals=TRUE }
tar_option_set(packages = c("tidyverse", "dplyr", "purrr", "readr", "tidyr", "ggplot2")) # I had to mention dplyr, purrr ect even though they are included in tidyverse.
options(tidyverse.quiet = TRUE)
```


```{r, echo=F}
#Remove R scripts from previous non-interactive runs
tar_unscript()
#tar_destroy()
```
</details>

</br>



# Get file names (target)
Our first target reads in all the file names in `data/publicationProfiles` and stores them in a single object (`ppls`), which we can then monitor for updates.

```{targets pp-ls}
##| tar_interactive: FALSE
tar_target(ppls, 
           list.files("data/publicationProfiles", full.names = T), 
           cue = tar_cue(mode = "thorough"), 
           format="file",
           packages = "tidyverse")
```

Then we import these files and compile them into long format using `compile_profiles()`.

Then the same for `data/indicatorProfiles`.

```{targets ip-ls}
##| tar_interactive: FALSE
tar_target(ipls, 
           list.files("data/indicatorProfiles", full.names = T), 
           cue = tar_cue(mode = "thorough"), 
           format="file",
           packages = "tidyverse")
```

# Compile profiles (function)
Here's a function to read all the CSV's and compile them in a long format.
We also take the file name and add that to the data set.

```{targets compile, tar_globals = TRUE}
##| tar_interactive: FALSE
compile_profiles <- function(files) {
  files |>
    set_names(basename) |>
    map(read.csv) %>%
  list_rbind(names_to = "fileName") |>
  tidyr::pivot_wider(names_from = parameter, values_from = value)}
```

# Import profiles (targets)
Let's read in and compile the publication profiles.

```{targets pp-import}
##| tar_interactive: FALSE
tar_target(publications_imported, compile_profiles(ppls),
           packages = "tidyverse")
```

And the indicator profiles in the same way.

```{targets ip-import}
##| tar_interactive: FALSE
tar_target(indicators_imported, compile_profiles(ipls),
           packages = "tidyverse")
```



# Create dummy data
<details><summary>Click to expand</summary>

Let's make a function to re-sample `import_indicators`  and populate a dummy data set which we can use to write generic code with.

First.
There are some columns that have multiple-choice fields separated with `|`.
For the publication profiles it's only pDirective, but this one is not so interesting, so I will ignore this for now.
In the indicator profiles we have:

<!-- ```{r mcFields, tar_simple=T} -->
<!-- mc <- c("iContinent", "iCountry", "iET", "dOrigin", "iBiome") -->
<!-- ``` -->

To scramble these we need a separate approach compared to just re-sampling rows.

Here is a function to take a vector (data frame column) of length x, 
make it longer based on a deliminator to become x+z, 
sample to length of x, 
and sample some again to combine and make multiple choice fields. 


```{targets scramble_ms, tar_globals=T}
scramble_ms <- function(x) {
  vector <- x |> 
    as.data.frame() |>
    separate_longer_delim(cols = x, delim=" | ") |>
    distinct()
  long <- sample(vector[,1], 150, replace = T)
  # add some double values
  secondvalue <- sample(long, 20) # in 20 places
  secondvalue <- secondvalue[secondvalue!= ""] # rm blanks
  rows <- sample(1:150, 20, replace = F) # pick random row(vector) positions
  long[rows] <-  paste(long[rows], secondvalue, sep= " | ") # paste second value 
  long <- str_replace(long, "^.[|].", "") # rm leading " | "
  return(long)
  }
```

Now we can use this function inside `mutate(across())`.

```{targets scramble, tar_globals=T}
##| tar_interactive: FALSE
scramble <- function(data) {
  #These are the multiple choice (mc) columns
  mc <- c("iContinent", "iCountry", "iET", "dOrigin", "iBiome")
  # resample to get 150 rows
  data[sample(1:nrow(data), 150, replace = T),] |>
    # replace the mc columns
    mutate(across(any_of(mc),scramble_ms))
}

```

```{targets dummyData}
tar_target(indicators_dummyData, scramble(indicators_imported))
```

</details>
</br>

# Plotting functions
Here are functions to plot data.

## Barplots
```{targets barplot, tar_globals = TRUE}
##| tar_interactive: FALSE

create_bar <- function(data, x) {
  data |>
    separate_longer_delim(x, " | ") |>
    ggplot() +
    geom_bar(aes_string(x = x),
             fill="#FFDB6D",
             colour="grey30") +
    theme_minimal(18)+
    coord_flip()+
    theme(axis.title.y = element_blank(),
          axis.title.x = element_blank())
}
```

# Figures (targets)
And here are the figure targets

## Country
```{targets barPlot_country}
tar_target(barPlot_country, create_bar(indicators_dummyData, "iCountry"),
           packages = "tidyverse")
```


## Continent
```{targets barPlot_continent}
tar_target(barPlot_continent, create_bar(indicators_dummyData, "iContinent"),
           packages = "tidyverse")
```


# Pipeline

If you ran all the `{targets}` chunks in non-interactive mode, then your R scripts are set up to run the pipeline.

```{r}
tar_make()
```

</br>

# Output
<!-- You can retrieve results from the `_targets/` data store using `tar_read()` or `tar_load()`. -->

## Raw data tables

### Imported publication profiles
<details><summary>Click to expand</summary>

```{r, echo=F}
reactable::reactable(tar_read(publications_imported),
          searchable = T,
          defaultPageSize=5,
          showPageSizeOptions=T,
          striped=T)
```

</details>

### Imported Indicator profiles

<details><summary>Click to expand</summary>

```{r, echo=F}
reactable::reactable(tar_read(indicators_imported),
          searchable = T,
          defaultPageSize=5,
          showPageSizeOptions=T,
          striped=T)
```

</details>

### Synthetic indicators data (dummy data)

<details><summary>Click to expand</summary>

```{r, echo=F}
reactable::reactable(tar_read(indicators_dummyData),
          searchable = T,
          defaultPageSize=5,
          showPageSizeOptions=T,
          striped=T)
```

</details>

</br>
</br>


## Figures

### Country
<details><summary>Click to expand</summary>
```{r, echo=F}
tar_read(barPlot_country)
```
</details>

### Continent
<details><summary>Click to expand</summary>
```{r}
tar_read(barPlot_continent)
```
</details>

# DAG
The `targets` dependency graph helps your readers understand the steps of your pipeline at a high level.

```{r}
tar_visnetwork()
```


